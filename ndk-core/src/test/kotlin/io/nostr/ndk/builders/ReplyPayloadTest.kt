package io.nostr.ndk.builders

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.nostr.ndk.crypto.NDKKeyPair
import io.nostr.ndk.crypto.NDKPrivateKeySigner
import io.nostr.ndk.models.NDKEvent
import io.nostr.ndk.models.NDKTag
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Test

/**
 * Test to demonstrate and verify the actual JSON payloads generated by reply builders.
 */
class ReplyPayloadTest {

    private val mapper = jacksonObjectMapper()

    @Test
    fun `demonstrate reply to root note payload`() = runTest {
        val signer = NDKPrivateKeySigner(NDKKeyPair.generate())
        // Original note (root)
        val originalNote = NDKEvent(
            id = "original123",
            pubkey = "authorpubkey123",
            createdAt = 1234567890,
            kind = 1,
            tags = emptyList(),
            content = "This is the original note",
            sig = "sig123"
        )

        // Create a reply
        val reply = originalNote.reply()
            .content("This is my reply!")
            .build(signer)

        // Print the payload
        println("\n=== REPLY TO ROOT NOTE ===")
        println("Original note ID: ${originalNote.id}")
        println("\nReply event JSON:")
        println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(
            mapOf(
                "id" to reply.id,
                "pubkey" to reply.pubkey,
                "created_at" to reply.createdAt,
                "kind" to reply.kind,
                "tags" to reply.tags,
                "content" to reply.content,
                "sig" to reply.sig
            )
        ))

        // Verify NIP-10 structure
        assertEquals(1, reply.kind)

        // Should have "e" tag for the original note with "root" marker
        val eTags = reply.tags.filter { it.name == "e" && it.values.size >= 2 }
        assertEquals(1, eTags.size)
        assertEquals(originalNote.id, eTags[0][0])

        if (eTags[0].values.size >= 3) {
            assertEquals("root", eTags[0][2])
        }

        // Should have "p" tag for the original author
        val pTags = reply.tags.filter { it.name == "p" && it.values.size >= 1 }
        assertEquals(1, pTags.size)
        assertEquals(originalNote.pubkey, pTags[0][0])
    }

    @Test
    fun `demonstrate reply in thread payload`() = runTest {
        val signer = NDKPrivateKeySigner(NDKKeyPair.generate())

        // Root note
        val rootNote = NDKEvent(
            id = "root123",
            pubkey = "rootauthor",
            createdAt = 1234567890,
            kind = 1,
            tags = emptyList(),
            content = "Root of thread",
            sig = "sig1"
        )

        // First reply to root
        val firstReply = NDKEvent(
            id = "reply1",
            pubkey = "replier1",
            createdAt = 1234567900,
            kind = 1,
            tags = listOf(
                NDKTag("e", listOf("root123", "", "root")),
                NDKTag("p", listOf("rootauthor"))
            ),
            content = "First reply",
            sig = "sig2"
        )

        // Reply to the reply (nested)
        val nestedReply = firstReply.reply()
            .content("Reply to the reply!")
            .build(signer)

        println("\n=== REPLY IN THREAD ===")
        println("Root note ID: ${rootNote.id}")
        println("First reply ID: ${firstReply.id}")
        println("\nNested reply event JSON:")
        println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(
            mapOf(
                "id" to nestedReply.id,
                "pubkey" to nestedReply.pubkey,
                "created_at" to nestedReply.createdAt,
                "kind" to nestedReply.kind,
                "tags" to nestedReply.tags,
                "content" to nestedReply.content,
                "sig" to nestedReply.sig
            )
        ))

        // Verify thread structure
        val eTags = nestedReply.tags.filter { it.name == "e" && it.values.size >= 2 }
        assertEquals(2, eTags.size)

        // Check that root is preserved
        val rootTag = eTags.find { it.values.size >= 3 && it[2] == "root" }
        assertEquals("root123", rootTag?.get(0))

        // Check that immediate parent is marked as "reply"
        val replyTag = eTags.find { it.values.size >= 3 && it[2] == "reply" }
        assertEquals("reply1", replyTag?.get(0))
    }

    @Test
    fun `demonstrate reply to article (NIP-22) payload`() = runTest {
        val signer = NDKPrivateKeySigner(NDKKeyPair.generate())

        // Article (kind 30023)
        val article = NDKEvent(
            id = "article123",
            pubkey = "author",
            createdAt = 1234567890,
            kind = 30023,
            tags = listOf(
                NDKTag("d", listOf("my-article-identifier")),
                NDKTag("title", listOf("My Article"))
            ),
            content = "Article content...",
            sig = "sig1"
        )

        // Reply to article (should be kind 1111 - generic reply)
        val reply = article.reply()
            .content("Great article!")
            .build(signer)

        println("\n=== REPLY TO ARTICLE (NIP-22) ===")
        println("Article kind: ${article.kind}")
        println("Article d tag: ${article.tags.find { it.name == "d" }?.get(0)}")
        println("\nReply event JSON:")
        println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(
            mapOf(
                "id" to reply.id,
                "pubkey" to reply.pubkey,
                "created_at" to reply.createdAt,
                "kind" to reply.kind,
                "tags" to reply.tags,
                "content" to reply.content,
                "sig" to reply.sig
            )
        ))

        // Verify NIP-22 structure
        assertEquals(1111, reply.kind)

        // Should have "K" tag (uppercase) for root kind
        val kTags = reply.tags.filter { it.name == "K" && it.values.size >= 1 }
        assertEquals(1, kTags.size)
        assertEquals("30023", kTags[0][0])

        // Should have "A" tag for addressable event
        val aTags = reply.tags.filter { it.name == "A" && it.values.size >= 1 }
        assertEquals(1, aTags.size)

        // A tag format: kind:pubkey:d-identifier
        val expectedATag = "${article.kind}:${article.pubkey}:my-article-identifier"
        assertEquals(expectedATag, aTags[0][0])
    }

}
